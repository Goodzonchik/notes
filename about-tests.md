### 1. Тесты могут найти баги там, где их никто не нашел
Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями.

Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.

#### Например:

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку в рантайме. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}

someFunction(null) //IDE и компилятор не будут ругаться
```



### 2. Помимо того, что код должен быть читаемым, код должеен быть тестируемым.

Код должен быть тестируемым,  практика в написании тестов позволяет писать более удобный код для тестирования.
Если вам легко написать на код тест, скорее всего это значит, что код легко читается, и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать.

Способы декомпозиции:
Например, в Angular-приложении легче протестировать сервис, чем компонент. Одним из способов упрощения тестирования будет вынесение логики в сервис, тем самым упростить тестирование.

```
Тут можно попробовать сделать пример компонента с запросом на бэк + отображение нотификации + какой-нибудь маппинг в pipe от rxds.


В упрощенном тесте будет лишь проверка того, какие view нам вернет новый сервис.
У компонента будет одна зависимость. И не нужно запариваться за кучу моков и  тестов и т.д. Тестируем только view-часть

```


Также стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения.
Протестировав отдельно абстракцию (например, реализуем ее через через Angular-сервис или функция для сложных вычислений), мы можем мокировать его ответы в месте использования при написании теста на интерацию этой абстракции.
Также можно выделить часть логики за фасад.

```
Тестируем компонент, который отрисовывает данные, например по компании. Для этого нужно вызвать несколько запросов к бэкенду.

Каждый вызов находится в отдельном сервисе и легко тестируется сам по себе.

Если делать вызовы последовательно в самом компоненте, например так

// TODO расписать поподробнее преобразования, чтобы было больше "плохого кода"
OnInit(){
  value1$ = service1.getData$().pipe(map(...));
  value2$ = service2.getData$().pipe(map(...));
  value3$ = service3.getData$().pipe(map(...));
  value4$ = service4.getData$().pipe(map(...));
  value5$ = service5.getData$().pipe(map(...));
}

В таком случае нам надо в тесте сделать mock-и для всех вызовов. И если мы будем тестировать отображение value5$, нам надо будет замокать вызовы всех сервисов, хотя бы на заглушки.

Хорошим вариантом может быть - сделать один сервис, который будет возвращать значения всех нужных нам сервисов. Своебразный фасад.

OnInit(){
  value1$ = facadeService.getData1$();
  value2$ = facadeService.getData2$();
  value3$ = facadeService.getData2$();
  value4$ = facadeService.getData2$();
  value5$ = facadeService.getData2$();
}

Сам тест
// TODO дописать примеры элегантного мокирования
```


### 3. Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. Также надо знать и инструменты. 

К ревью и составлению нужно подключать более компетентных людей в тестах,  например тестировщиков. Им виднее какие тесты нужны,  каких не хватает,  а так же смогут научить вас писать правильные тесты 
К слову о шифт-лефт тестировании

### 4. Не всегда покрытие говорит верные цифры
Например, можно написать тест, который делает should created для компонента или сервиса. 
В таком случае каждый импорт будет засчитан за строку в покрытии.

Научитесь понимать какие метрики и за что отвечают.  Научитесь их читать

Пример: в rxds если сделать map, который поменяет порядок данных. По идее надо скормить туда 2 набора данных, отсортированный для одного теста и не сортированный для проверки сортировки (!!! проверить кейс)

```
// Пример метода:

getUsers$(): Observable<HttpResponse<User[]>> {
  return this.httpClient.get<User[]>(url)
             .pipe(
                map(users => users.sort((user1, user2) => user1.birthDate - user2.birthDate))
             )

  );
}

// Пример теста:

it('При получении списка юзеров, проверить что они отсортированны по дате', done => {
    when(httpClientMock.get(url)).thenReturn(...);
            

    // TODO дописать marble пример.

    expect(testService.getUsers$()).toBeObservable(expected);
```

5. Если нет тестов совсем, то не пренебрегайте хотя бы тестом, который создается по умолчанию should created.
Такой тест может показать изменение зависимостей.


6. Нужны договорённости,  тесты - это такой же код и требует таких же процессов, гайдов и 
прочего.
К таким договоренностям может относится код-стайлы.
Правила именования и формирования самого теста, например ААА.

Но одной из важных договоренностей, или даже обязанностей - является следующее утверждение: тесты нужно писать и нужно следить за их актуальность


8. Тест не дополнительная работа,  а часть текущей.  Тест - это инструмент разработчика, такой же как подсказки в IDE, только делаете его вы сами. 
Подсказка в IDE подскажет правильность вашего кода на соответствие линтеров и компилируемость, а тест покажет работоспособность вашего кода.


## Советы

### Пиши тесты сразу
Во-первых, ты сейчас в контексте задачи, помнишь весь код, понимаешь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Во-вторых, в будущем, скорее всего будет более важная или более интересная задача на создание продуктовой фичи или рефакторинг.
В-третьих, если задачу уже приняли, или она даже дошла до продакшена, то психологически она уже считается завершенной и вы вряд ли сами захотите вернуться к ней.
В-четвертых, лучше сразу заложить время в оценку задачи, тем самым вы оставите себе время на спокойное написание тестов. У представителей бизнеса будет меньше вопросов в духе "а нельзя как-то без тестов", если им просто не сказать об этом.




__________________________________________________________
Рандомные мысли:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- 
