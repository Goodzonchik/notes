### 1. Тесты могут найти баги там, где их никто не нашел
Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями.

Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.

#### Например:

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}
```



### Помимо того, что код должен быть читаемым, код должеен быть тестируемым.

1. Код должен быть тестируемым,  практика в написании тестов позволяет писать более удобный код для тестирования.
Если вам легко написать на код тест, значит код легко читается и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать.

Способы декомпозиции:
Например, в ангуляр приложении легче протестировать сервис, чем компонент => можно постараться вынести логику в сервисы, тем самым упростить тестирование.

Также стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения.
Протестировав отдельно абстракцию (например, реализуем ее через через Angular-сервис), мы можем мокировать его ответы в месте использования при написании теста на интерацию этой абстракции.
Также можно выделить часть логики за фасад.


### Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. Также надо знать и инструменты. 

### Не всегда покрытие говорит верные цифры
Например, можно написать тест, который делает should created для компонента или сервиса. 
В таком случае каждый импорт будет засчитан за строку в покрытии.

Научитесь понимать какие метрики и за что отвечают.  Научитесь их читать

Пример: в rxds если сделать map, который поменяет порядок данных. По идее надо скормить туда 2 набора данных, отсортированный для одного теста и не сортированный для проверки сортировки (!!! проверить кейс)

5. Если нет тестов совсем, то не пренебрегайте хотя бы тестом, который создается по умолчанию should created.
Такой тест может показать изменение зависимостей.

5. Тесты нужно писать и нужно следить за их актуальность

6. Нужны договорённости,  тесты - это такой же код и требует таких же процессов, гайдов и прочего. 

7. К ревью и составлению нужно подключать более компетентных людей в тестах,  например тестировщиков. Им виднее какие тесты нужны,  каких не хватает,  а так же смогут научить вас писать правильные тесты 
К слову о шифт-лефт тестировании

8. Тест не дополнительная работа,  а часть текущей.  Тест - это инструмент разработчика, такой же как подсказка в IDE, только делаете его вы сами. 
Подсказка в IDE подскажет правильность вашего кода на линтеры и компилируемость, а тест покажет работоспособность вашего кода

## Советы

### Пиши тесты сразу
Во-первых, ты сейчас в контексте задачи, помнишь весь код, понимаешь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Во-вторых, в будущем, скорее всего будет более важная или более интересная задача на создание продуктовой фичи или рефакторинг.
В-третьих, если задачу уже приняли, то психологически она уже считается завершенной и вы вряд ли сами захотите вернуться к ней





__________________________________________________________
Помойка мыслей:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- 
