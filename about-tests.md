### 1. Тесты могут найти баги там, где их никто не нашел
  Пожалуй это самое очевидное утверждение, объясняющее для чего стоит писать тесты. Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями. Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.
  Если у вас в коде не было тестов, то тесты могут выступить не только как гарант качества кода, но и как инструмент для того, чтобы можно было понять что делает код. Изучить его не только через чтение и разбор, но и через тесты. При таком подходее вы сможете лучше понять взаимосвязь между частями кода, и заодно получите покрытие тестами, что убережет от ошибок в будущем.

### 2. Помимо того, что код должен быть читаемым, код должеен быть тестируемым.
  Очень часто пишут о том, что код должен быть легкочитаемым, легкоподдерживаемый, но куда реже можно найти статьи, где будет написано о том, что код должен быть еще и  тестируемым. Если вам легко написать на код тест, скорее всего это значит, что код легко читается, и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать в будущем.
  
  В различных языках, библиотека и фреймворка есть свои конструкции, которые легче тестировать чем другие. Например, в Angular протеститровать сервис проще и дешевле, чем компонент. Это связано как минимум с тем, сервис тестируется как обычный класс, в то время как у компонента есть еще шаблон, взаимодействие с которым нужно тоже протестировать, если [хуки жизненного цикла](https://angular.io/guide/lifecycle-hooks). В качестве примера можно взять простую задачу - получение каких-то данных с бэкенда и их отображение. Нам потребуется получить данные, произвести какие-нибудь преобразования и вывести их в шаблоне. Часто стречал картину, когда данные получают в хуке `ngOnInit`, там же преобразовывали, там же обрабатывали ошибку ит .д.



```
export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url);
}



export class UsersComponent implements OnInit{
  users$: Observable<User>;
  
  constructor(private errorService: ErrorService, private userService: UserService) {}

  ngOnInit(): void {
    this.users$ = this.userService.getUsers.pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
  }
}
```

Чем плох такой подход для тестов. Во первых, компонент не только показыват данные, но и производит кучу различных манипуляций с данными.
Для того, чтобы проверить отобразится ли у нас нотификация, нам нужно провести ряд действий, в том числе инициализировать компонент.
Также стоит отметить, что это у нас может быть не только отображению юзеров в компоненте, а если будут и другие подписки, то возможно, потребуется мокать логику получения юзеров, чтобы проверить другие подписки.

Давайте перенесем логику в сервис, а в самом компоненте оставим только подписку на данные.

```
export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers$<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url).pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
    }
}

export class UsersComponent implements OnInit{
  users$: Observable<User>;
  
  constructor(private userService: UserService) {}

  ngOnInit(): void {
     this.users$ = this.userService.getUsers$();
  }
}
```

Что получим в итоге: логика обработки данных будет инкапсулирована в сервисе. Соответственно для тестирования нам достаточно замокировать один сервис и для каждого теста на отображение передавать нужные данные. В сервисе же мы протестируем логику, но в данном случае нам не потребуется уже работать с компонентом. Логика также инкапсулирована в сервисе.
При разработке стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения. Абстракцию можно протестировать отдельно (например, реализуем ее через через Angular-сервис или функция для сложных вычислений), а при тесте места вызова мы можем мокировать ее ответы.


Также не стоит забывать и про другие принципы хорошего кода. Старайтесь избегать большого количества аргументов. Чем больше аргументов у метода или функции, тем больше вариантов поведения, соответственно больше тестов. Также не стоит забывать, что если у вас используется в коде класс, то его конструктор также имеет аргументы, и это тоже повлияет на сложность кода и количество тестов. 

Навык писать тестируемый код приходит с опытом, также как и опыт писать хороший код. Единственнный путь - это писать тесты много тестов.

### 3. Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. Также надо знать и инструменты. 

При передаче задачи в ревью, стоит уделить внимание не только на сам код, но и на тесты. Разумно будет подключить на этой стадии более компетентных людей в тестах, а именно QA-специалистов. Они смогут сказать, каких тестов не хватает или как лучше поправить тесты. Также они могут показать какие-то моменты связанные с теорией тестирование, чтобы разработчик мог правильные тесты.
При такам подходе, появляется большее смещение в сторону shiftleft-тестировании, так как тестирование больше и правильнее раскрывается еще на стадии ревью, перед тестированием.

#### Например:

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку в рантайме. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}

someFunction(null) //IDE и компилятор не будут ругаться, можно легко забыть про такой кейс при тестировании.
```

*Пометки по пункту:*
*Можно использовать отчет по code coverage, чтобы проверить все ли ветки(branches) были покрыты тестами*

И еще хотелось бы отметить такую штуку, как метрики кода. Особое внимание можно уделить [цикломатической сложности](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C) кода. Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Соответственно, чем больше у нас различных ветвлений, тем выше становится сложность кода, а соответственно и количество и сложность тестов увеличивается. В WebStorme-е можно настроить эту метрику. Тем самым сократиться сложность кода, и можно будет легче писать тесты. (Посмотреть как это сделат в Webstorm, и посмотреть, есть ли такое для VsCode).
Для уменьшения сложности кода стоит использовать встроенные функции или плагины для измерения метрик кода.
Например, для VS Code есть расширение codemetrics https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics
А в Webstrom есть встроенные.



### 4. Не всегда тестовое покрытие говорит верные цифры.
Например, можно написать тест, который по умолчанию проверяет создание компонента или сервиса в Angular. В таком случае некоторые импорты будут засчитан за строку в покрытии, если у вас класс, то при его инициализации конструктор тоже будет засчитан как покрытый тестами.


Если есть enum ли какая-то модель данных, то при ее использовании тоже увеличивается тестовое покрытие, хотя enum может не использоваться вообще, а быть ненужным полем, которое отпавили с бэка в dto, но на фронте оно не нужно.

Научитесь понимать какие метрики и за что отвечают.  Научитесь их читать.


Также, если у вас есть сортировка данных и вы по ошибке отправили туда отсортированный набор данных в тесте, то покрытие этого участка кода будет 100%, хотя по факту мы не знаем, возвращает ли нам нужный участок кода сортировку в нужном порядке.
```
function userSort(users: User[]) => {
  return users.sort((user1, user2) => user1.age - user2.age))
};

```

Также, если вы настроили сборку данны code coverage, например на файлы с ширением `*.ts`, то туда попадут также и файлы, которые содержат отдельно хранящиеся типы, интерфейсы, перечисления и т.д. Вполне возможна ситуация, когда в отчет попадут неиспользумые части кода. Например, есть dto модель, у которой одно из полей имеет значение в виде enum-а. Но, это поле может не использоваться в приложении, но указано для того, чтобы данные были актуальные.

Например, у нас есть интерфейс для получения пользователей, есть имя, возвраст и гражданство. Dto хранит в себе полный набор данных, чтобы не было противоречий и недосказанности в моделях на бэкенде и фронтенде. Но, гражданство мы можем и не использовать для вывода. Но если напишем тест на получение всей модели с бэкенда, то Citizen будет засчитан как строка, которая использовалась в тесте. Тем самым мы поднимем уровень тестового покрытия, но при этом ничего не проверим фактически.
```
export interface UserDto {
  name: string;
  age: number;
  citizen: Citizen
} 
```


### 5. Написание тестов - это не дополнительная работа, а инструмент разработчика. Его можно сравнить с подсказками в вашей IDE, единственное различие, вы пишите его сами.
Подсказка в IDE подскажет правильность вашего кода на соответствие линтерам, форматировани и  на компилируемость, в то время как тест покажет работоспособность вашего кода и не даст вам сломать приложение при выполнении различных доработок.

Тесты - это инвестиция в будущее качество проекта. Даже если вы идеально знаете свой код и сможете внести доработки, которые его не сломают, то нет гарантии, что его не сломает кто-нибудь другой.

Часто разработчики делают простые, казалось бы, рефакторинги, и не делают потом проверок за собой, так как уверены, что правки были простыми и не сломали ничего. На практике далеко не редки случаи, когда подобные простые доработки приводили к ошибке, потому что очевидные и простые изменения в поведении приводили к поломкам.

Тесты помогают работать программистам более уверенно в тех частях приложения, с которыми они не знакомы. Да и вернуться к коду, который был написан год назад тоже бывает трудно, особенно в больших системах.

### 6. Обязательно выработайте договоренности по тому, как писать тесты.
  Тесты - это такой же код и требует таких же процессов, гайдов, линтеров и подобного.
Пожалуй, самая главная договоренность, а лучше сказать обязанность - тесты нужно писать и нужно следить за их актуальностью. 
Если у вас еще нет тестов в приложении, то стоит договориться о том, как покрывать тестами, например писать тесты на новый функционал, а на старый функционал завести задачи с разным приоритетом критичности и брать их как технический долг. К подобным вопросам тестирования очень полезно будет привлекать коллег QA-специалистов, которые смогут дать советы исходя из своей компетенции.

### 7.Пиши тесты сразу
Пока пишешь код для конкретной задачи, то находишься в ее контексте, помнишь код и соответственно понимаешь и помнишь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Если по какой-то причине решили отложить тесты отдельной задачей, то скорее всего будет задача с приоритетом выше, чем тесты. И тесты будут очень долго ждать своего часа. А вероятность того, что будут внесены новые правки в код будет повышаться с каждым часом.
Если задача не дождалась тестов и разработка по ней была закончена, а может быть она даже успела дойти до релиза, то психологически она уже считается завершенной, и вы вряд ли сами захотите вернуться к ней.

Лучший совет, чтобы избегать этого: начать писать тесты и сразу же заложить время в оценку задачи, тем самым вы оставите себе время на спокойное написание тестов. У представителей бизнеса будет меньше вопросов в духе "а нельзя как-то без тестов/побыстрее". Но стоит заранее обговаривать такие решения с командой.


__________________________________________________________
Рандомные мысли:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- Не нужно бояться того, что тесты будут падать после изменений. Это показательно того, что что-то изменилось. И нужно проанализировать - сломали ли вы что-нибудь или же старые тесты перестали соответствовать новому поведению
- Нужно вступление нормальное
- Нужно завершение


Поправить порядок по тезисам
1. тесты нужны
2. код надо писать тестируемым
3. чтобы писать тестируемо надо юзать инструменты (тут тоже про знание инструментов, можно объединить с 4-м)
4. инструенты надо знать
5. тесты не доп.работа, а инструмент
6. договоренности
7. пиши тесты сразу (совет)
