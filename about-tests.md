### 1. Тесты могут найти баги там, где их никто не нашел
  Пожалуй это самое очевидное утверждение, объясняющее для чего стоит писать тесты. Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями. Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.
 
  Если у вас в коде не было тестов, то тесты могут выступить не только как гарант качества кода, но и как инструмент для того, чтобы можно было понять что делает код. Изучить его не только через чтение и разбор, но и через тесты. При таком подходее вы сможете лучше понять взаимосвязь между частями кода, и заодно получите покрытие тестами, что убережет от ошибок в будущем.

### 2. Помимо того, что код должен быть читаемым, код должен быть тестируемым.
  Очень часто пишут о том, что код должен быть легкочитаемым, легкоподдерживаемый, но куда реже можно найти статьи, где будет написано о том, что код должен быть еще и  тестируемым. Если вам легко написать на код тест, скорее всего это значит, что код легко читается, и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать в будущем.
  
  В различных языках, библиотека и фреймворка есть свои конструкции, которые легче тестировать чем другие. Например, в Angular протеститровать сервис проще и дешевле, чем компонент. Это связано как минимум с тем, сервис тестируется как обычный класс, в то время как у компонента есть еще шаблон, взаимодействие с которым нужно тоже протестировать, есть еще [хуки жизненного цикла](https://angular.io/guide/lifecycle-hooks), которые тоже накладывают дополнительные ограничения в тестах.
  
  В качестве примера можно взять простую задачу - получение каких-то данных с бэкенда и их отображение. Нам потребуется получить данные, произвести какие-нибудь преобразования и вывести их в шаблоне. Часто доводилось встречать картину, когда данные получают в хуке `ngOnInit`, там же преобразовывали, там же обрабатывали ошибку и т.д.

```
export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url);
}



export class UsersComponent implements OnInit{
  users$: Observable<User>;
  
  constructor(private errorService: ErrorService, private userService: UserService) {}

  ngOnInit(): void {
    this.users$ = this.userService.getUsers.pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
  }
}
```

Чем плох такой подход для тестов. Во первых, компонент не только показывает данные, но и производит кучу различных манипуляций с данными. Для того, чтобы проверить отобразится ли у нас нотификация, нам нужно провести ряд действий, в том числе инициализировать компонент. Также стоит отметить, что у нас может быть не только отображение пользователей в компоненте, может быть страница агрегирующая в себе несколько разных подписок. В таком случае потребуется мокать логику получения пользователей, чтобы проверить другие подписки, которые идут ниже, чтобы тесты работали корректоно, и иногда одной строки для мока мало.


Давайте перенесем логику в сервис, а в самом компоненте оставим только подписку на данные.

```
export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers$<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url).pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
    }
}

export class UsersComponent implements OnInit{
  users$: Observable<User>;
  
  constructor(private userService: UserService) {}

  ngOnInit(): void {
     this.users$ = this.userService.getUsers$();
  }
}
```

Что получим при таком рефакторинге: логика обработки данных будет инкапсулирована в сервисе. Соответственно для тестирования нам достаточно замокировать один сервис и для каждого теста на отображение передавать нужные данные. В сервисе же мы протестируем логику, но в данном случае нам не потребуется уже работать с компонентом. Логика также инкапсулирована в сервисе.

При разработке стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения. Абстракцию можно протестировать отдельно (например, реализуем ее через Angular-сервис или функцию для сложных вычислений), а при тесте места вызова мы можем мокировать ее возможные варианты ответов.

Также не стоит забывать и про другие принципы хорошего кода. Старайтесь избегать большого количества аргументов. Чем больше аргументов у метода или функции, тем больше вариантов поведения, соответственно больше тестов. Также не стоит забывать, что если у вас используется в коде класс, то его конструктор также имеет аргументы, и это тоже повлияет на сложность кода и количество тестов. 

Навык писать тестируемый код приходит с опытом, также как и опыт писать хороший код. Единственнный путь - это писать тесты много тестов.

### 3. Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. 

При передаче задачи в ревью, стоит уделить внимание не только на сам код, но и на тесты. Разумно будет подключить на этой стадии более компетентных в тестах людей, а именно QA-специалистов. Они смогут сказать, каких тестов не хватает или как лучше поправить тесты. Также они могут показать какие-то моменты связанные с теорией тестирования, чтобы разработчик мог правильные тесты, облегчая работу всем в будущем. При такам подходе, появляется большее смещение в сторону shiftleft-тестирования, так как тестирование больше и правильнее раскрывается еще на стадии ревью, перед стадией тестирования.

### 4. Также надо знать и инструменты, чтобы писать хорошие тесты.

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку в рантайме. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}

someFunction(null) //IDE и компилятор не будут ругаться, можно легко забыть про такой кейс при тестировании.
```

Включение строгой проверки `null` позволяет избегать кучи различных кейсов, когда у нас нет значения. Ведь зачастую мы возвращаем null для того, чтобы показать, что что-то пошло не так. А когда проверяем свой код, то делаем акцент на успешных кейсах, забывая те, которые приводят к ошибкам.

И еще хотелось бы отметить такую штуку, как метрики кода. Особое внимание можно уделить [цикломатической сложности](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C) кода. Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Соответственно, чем больше у нас различных ветвлений, тем выше становится сложность кода, а соответственно и количество и сложность тестов увеличивается.
В WebStorme-е можно включить расчет этих метрик в настройках. ![image](https://user-images.githubusercontent.com/19908027/218381710-557fe075-ea46-4fe1-a204-b40a491c7ba9.png)
А для VS Code есть расширение codemetrics https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics. Автор утверждает, что там не цикломатическая сложность, а приближенные ее вычисления.

Если вы знаете метрики сложности кода, и стремитись их снизить, то по сути вы боретесь со сложностью кода и тем самым упрощаете написание тестов.

### 5. Не всегда тестовое покрытие говорит верные цифры.
Еще одним из полезных инструментов для написания тестов является отчет code coverage, который может показать все ли строки/условия/функции вашего кода были задействованны в тестах. Важный акцент на слове **задействованы**, а не протестированы. Code coverage не дает 100% гарантии того, что ваш код покрыт нужными функциональными тестами. Его можно использовать как отчет о том, что в текущем функционале еще не успели протестировать и нет ли пропущенных мест.

Например, можно написать тест, который по умолчанию проверяет создание компонента или сервиса в Angular. В таком случае некоторые импорты будут засчитаны за строки кода покрытые тестами. А если у вас класс, то при его инициализации конструктор тоже будет засчитан как покрытый тестами.

Также, если у вас есть сортировка данных и вы по ошибке отправили туда отсортированный набор данных в тесте, то покрытие этого участка кода будет 100%, хотя по факту мы не знаем, возвращает ли нам нужный участок кода результат в нужном порядке.

```
function userSort(users: User[]) => {
  return users.sort((user1, user2) => user1.age - user2.age))
};
```

Также, если вы настроили сборку данны code coverage, например на файлы с ширением `*.ts`, то туда попадут файлы, которые содержат отдельно хранящиеся типы, интерфейсы, перечисления и т.д. Вполне возможна ситуация, когда в отчет попадут неиспользумые части кода. Например, есть dto-модель, у которой одно из полей имеет значение в виде enum-а. Но, это поле может не использоваться в приложении, но указано для того, чтобы данные были актуальные. Например, у нас есть интерфейс для получения пользователей, есть имя, возвраст и гражданство. Dto хранит в себе полный набор данных, чтобы не было противоречий и недосказанности в моделях на бэкенде и фронтенде. Но, гражданство мы можем и не использовать для вывода. Но если напишем тест на получение всей модели с бэкенда, то enum Citizen будет засчитан полностью или частично, как покрытый тестами. Тем самым мы поднимем уровень тестового покрытия, но при этом ничего не проверим фактически.

```
export interface UserDto {
  name: string;
  age: number;
  citizen: Citizen;
} 
```

Все эти примеры приведут к тому, что в вашем code coverage будет процент покрытия выше, чем он есть на самом деле. Научитесь понимать какие метрики и за что отвечают, чтобы правильно полагаться на них. Научитесь их правильно читать.

### 6. Написание тестов - это не дополнительная работа, а инструмент разработчика. Его можно сравнить с подсказками в вашей IDE, единственное различие, вы пишите его сами.
Подсказка в IDE подскажет правильность вашего кода на соответствие линтерам, форматированию и  на компилируемость, в то время как тест покажет работоспособность вашего кода и не даст вам сломать приложение при выполнении различных доработок. Тесты - это инвестиция в будущее качество проекта. Даже если вы идеально знаете свой код и сможете внести доработки, которые его не сломают, то нет гарантии, что его не сломает кто-нибудь другой.

Часто разработчики делают простые, казалось бы, рефакторинги, и не делают потом проверок за собой, так как уверены, что правки были простыми и не сломали ничего. На практике далеко не редки случаи, когда подобные простые доработки приводили к ошибке, потому что очевидные и простые изменения в поведении приводили к поломкам.

Тесты помогают работать программистам более уверенно в тех частях приложения, с которыми они не знакомы. Да и вернуться к коду, который был написан год назад тоже бывает трудно, особенно в больших системах.

*На ранних этапах тестирования, может показаться, что команда теряет продуктивность, но после того, как количество покрытия будет подходить, примерно к 50%, вы начнете выигрывать. Станете меньше тратить времени на изучение кода. Будете допускать меньше ошибок и тем самым больше оставите времени на разработку нового функционала.* (Спорная мысль для этого раздела).

### 7. Обязательно выработайте договоренности по тому, как писать тесты.
  Тесты - это такой же код и требует таких же процессов, гайдов, линтеров и подобного.
Пожалуй, самая главная договоренность, а лучше сказать обязанность - тесты нужно писать и нужно следить за их актуальностью. 
Если у вас еще нет тестов в приложении, то стоит договориться о том, как покрывать тестами, например писать тесты на новый функционал, а на старый функционал завести задачи с разным приоритетом критичности и брать их как технический долг. К подобным вопросам тестирования очень полезно будет привлекать коллег QA-специалистов, которые смогут дать советы исходя из своей компетенции.

### 8.Пиши тесты сразу
Пока пишешь код для конкретной задачи, то находишься в ее контексте, помнишь код и соответственно понимаешь и помнишь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Если по какой-то причине решили отложить тесты отдельной задачей, то скорее всего будет задача с приоритетом выше, чем тесты. И тесты будут очень долго ждать своего часа. А вероятность того, что будут внесены новые правки в код будет повышаться с каждым часом.
Если задача не дождалась тестов и разработка по ней была закончена, а может быть она даже успела дойти до релиза, то психологически она уже считается завершенной, и вы вряд ли сами захотите вернуться к ней.

Лучший совет, чтобы избегать этого: начать писать тесты и сразу же заложить время в оценку задачи, тем самым вы оставите себе время на спокойное написание тестов. У представителей бизнеса будет меньше вопросов в духе "а нельзя как-то без тестов/побыстрее". Но стоит заранее обговаривать такие решения с командой.


__________________________________________________________
Рандомные мысли:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- Не нужно бояться того, что тесты будут падать после изменений. Это показательно того, что что-то изменилось. И нужно проанализировать - сломали ли вы что-нибудь или же старые тесты перестали соответствовать новому поведению
- Нужно вступление нормальное
- Нужно завершение


Поправить порядок по тезисам
1. тесты нужны
2. код надо писать тестируемым
3. чтобы писать тестируемо надо юзать инструменты (тут тоже про знание инструментов, можно объединить с 4-м)
4. инструенты надо знать
5. тесты не доп.работа, а инструмент
6. договоренности
7. пиши тесты сразу (совет)
