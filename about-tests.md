Тесты один из мощнейших инструментов разработки программного обеспечения. Сегодня попытаемся разобраться в чем 

### 1. Тесты могут найти баги там, где их никто не нашел
Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями.

Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.

Если у вас в коде не было тестов, то тесты могут выступить не только как гарант качества кода, но и как инструмент для того, чтобы можно было понять что делает код. Изучить его не только через чтение и разбор, но и через тесты. При таком подходее вы сможете лучше понять взаимосвязь между частями кода, и заодно получите покрытие тестами, что убережет от ошибок в будущем.

### 2. Помимо того, что код должен быть читаемым, код должеен быть тестируемым.

Очень часто пишут о том, что код должен быть легкочитаемы, легкоподдерживаемый, но куда реже можно найти статьи, где будет написано о том, что код должен быть еще и легко тестируемым. Если вам легко написать на код тест, скорее всего это значит, что код легко читается, и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать в будущем. Подобный навык написания тестируемого кода хорошо развивается, если начать активно писать тесты.

Например, в Angular протеститровать сервис проще и дешевле, чем компонент. Это связано как минимум с тем, сервис тестируется как обычный класс, в то время как у компонента есть еще шаблон, взаимодействие с которым нужно тоже протестировать, если [хуки жизненного цикла](https://angular.io/guide/lifecycle-hooks).


Способы декомпозиции:
Например, в Angular-приложении легче протестировать сервис, чем компонент. Одним из способов упрощения тестирования будет вынесение логики в сервис, тем самым упростить тестирование.


В качестве примера можно взять простую задачу - получение каких-то данных с бэкенда и их отображение. Нам потребуется получить данные, произвести какие-нибудь преобразования и вывести их в шаблоне. Част

```
export class UsersComponent implements OnInit{
  users$: Observable<User>;
  
  constructor(private errorService: ErrorService, private httpClient: HttpClient) {}

  ngOnInit(): void {
    const url = 'https://example.com/getUsers';

        this.users$ = this.http.get<User>(url).pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
  }
}


export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url).pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
    }
}




// У нас есть сервис для запроса данных с бэкенда

export class UserService {
    constructor(private http: HttpClient) { }

    public getUsers<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url).pipe(
                    take(1),
                    catchError(error => {
                        this.errorService.showNotification('get users error');
                        
                        return of([])
                    }),
                    map(users => ...))
                   );
    }
}

// 

В упрощенном тесте будет лишь проверка того, какие view нам вернет новый сервис.
У компонента будет одна зависимость. И не нужно запариваться за кучу моков и  тестов и т.д. Тестируем только view-часть

```


Также стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения.
Протестировав отдельно абстракцию (например, реализуем ее через через Angular-сервис или функция для сложных вычислений), мы можем мокировать его ответы в месте использования при написании теста на интерацию этой абстракции.
Также можно выделить часть логики за фасад.

```
Тестируем компонент, который отрисовывает данные, например по компании. Для этого нужно вызвать несколько запросов к бэкенду.

Каждый вызов находится в отдельном сервисе и легко тестируется сам по себе.

Если делать вызовы последовательно в самом компоненте, например так

// TODO расписать поподробнее преобразования, чтобы было больше "плохого кода"
OnInit(){
  value1$ = service1.getData$().pipe(map(...));
  value2$ = service2.getData$().pipe(map(...));
  value3$ = service3.getData$().pipe(map(...));
  value4$ = service4.getData$().pipe(map(...));
  value5$ = service5.getData$().pipe(map(...));
}

В таком случае нам надо в тесте сделать mock-и для всех вызовов. И если мы будем тестировать отображение value5$, нам надо будет замокать вызовы всех сервисов, хотя бы на заглушки.

Хорошим вариантом может быть - сделать один сервис, который будет возвращать значения всех нужных нам сервисов. Своебразный фасад.

OnInit(){
  value1$ = facadeService.getData1$();
  value2$ = facadeService.getData2$();
  value3$ = facadeService.getData2$();
  value4$ = facadeService.getData2$();
  value5$ = facadeService.getData2$();
}

Сам тест
// TODO дописать примеры элегантного мокирования
```




Старайтесь избегать большого количества аргументов. Чем больше аргументов у метода или функции, тем больше вариантов поведения, соответственно больше тестов. Также не стоит забывать, что если у вас есть класс, то его конструктор также имеет аргументы, и это тоже повлияет на сложность кода и количество тестов. 


Здесь стоит сделать упор на снижение **цикломатическая сложности** кода. В WebStorme-е можно настроить эту метрику. Тем самым сократиться сложность кода, и можно будет легче писать тесты. (Посмотреть как это сделат в Webstorm, и посмотреть, есть ли такое для VsCode).
Для уменьшения сложности кода стоит использовать встроенные функции или плагины для измерения метрик кода.
Например, для VS Code есть расширение codemetrics https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics
А в Webstrom есть встроенные.


*Cohetion и Coupling (подумать над их отншением к качеству кода и легкости тестирования)*
*Статические анализаторы кода, например SonarCube и подобные*
*Дублирование кода. Получается, что нужно и тестов в два раза больше. Одна из причин появления дублирования кода, если у нас есть две сущности, которые в текущий момент очень похожи по поведению, но в будущем поведение сильно изменится.*
*принцип единой ответственности*

### 3. Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. Также надо знать и инструменты. 

При передаче задачи в ревью, стоит уделить внимание не только на сам код, но и на тесты. Разумно будет подключить на этой стадии более компетентных людей в тестах, а именно QA-специалистов. Они смогут сказать, каких тестов не хватает или как лучше поправить тесты. Также они могут показать какие-то моменты связанные с теорией тестирование, чтобы разработчик мог правильные тесты.
При такам подходе, появляется большее смещение в сторону shiftleft-тестировании, так как тестирование больше и правильнее раскрывается еще на стадии ревью, перед тестированием.

#### Например:

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку в рантайме. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}

someFunction(null) //IDE и компилятор не будут ругаться, можно легко забыть про такой кейс при тестировании.
```

*Пометки по пункту:*
*Можно использовать отчет по code coverage, чтобы проверить все ли ветки(branches) были покрыты тестами*


### 4. Не всегда покрытие говорит верные цифры
Например, можно написать тест, который делает should created для компонента или сервиса. 
В таком случае каждый импорт будет засчитан за строку в покрытии.

Научитесь понимать какие метрики и за что отвечают.  Научитесь их читать.

Если есть enum ли какая-то модель данны, то при ее использовании тоже увеличивается тестовое покрытие, хотя enum может не использоваться вообще, а быть ненужным полем, которое отпавили с бэка в dto, но на фронте оно не нужно.

Пример: в rxds если сделать map, который поменяет порядок данных. По идее надо скормить туда 2 набора данных, отсортированный для одного теста и не сортированный для проверки сортировки (!!! проверить кейс)

```
// Пример метода:

getUsers$(): Observable<HttpResponse<User[]>> {
  return this.httpClient.get<User[]>(url)
             .pipe(
                map(users => users.sort((user1, user2) => user1.age - user2.age))
             )

  );
}

// Пример теста:

it('При получении списка юзеров, проверить что они отсортированны по дате', done => {
    when(httpClientMock.get(url)).thenReturn(...);
            

    // TODO дописать marble пример.

    expect(testService.getUsers$()).toBeObservable(expected);
```

Также, если вы настроили сборку данны code coverage, например на файлы с ширением `.ts`, то туда попадут также и файлы, которые содержат отдельно хранящиеся типы, интерфейсы, перечисления и т.д. Вполне возможна ситуация, когда в отчет попадут неиспользумые части кода. Например, есть dto модель, у которой одно из полей имеет значение в виде enum-а. Но, это поле может не использоваться в приложении, но указано для того, чтобы данные были актуальные.
```
export interface someDto {
} 
```


### 5. Обязательно выработайте договоренности по тому, как писать тесты. Тесты - это такой же код и требует таких же процессов, гайдов и тому подобного.
К таким договоренностям может относится код-стайлы.
Правила именования и формирования самого теста, например ААА.
Также можно привлекать вашего коллегу QA-специалиста, который тоже сможет подсказать какие-то моменты, которые можно упустить. 

Но одной из важных договоренностей, или даже обязанностей - является следующее утверждение: тесты нужно писать и нужно следить за их актуальностью. 

Но стоит задумать о том, чтобы начать добавлять тесты в свое приложение, например:
писать тесты на новый функционал, а на старый функционал завести задачи с разным приоритетом критичности и брать их как технический долг.

### 6. Написание тестов - это не дополнительная работа, а инструмент разработчика. Его можно сравнить с подсказками в вашей IDE, единственное различие, вы пишите его сами.
Подсказка в IDE подскажет правильность вашего кода на соответствие линтерам, форматировани и  на компилируемость, в то время как тест покажет работоспособность вашего кода и не даст вам сломать приложение при выполнении различных доработок.

Тесты - это инвестиция в будущее качество проекта. Даже если вы идеально знаете свой код и сможете внести доработки, которые его не сломают, то нет гарантии, что его не сломает кто-нибудь другой.

Часто разработчики делают простые, казалось бы, рефакторинги, и не делают потом проверок за собой, так как уверены, что правки были простыми и не сломали ничего. На практике далеко не редки случаи, когда подобные простые доработки приводили к ошибке, потому что очевидные и простые изменения в поведении приводили к поломкам.

Тесты помогают работать программистам более уверенно в тех частях приложения, с которыми они не знакомы. Да и вернуться к коду, который был написан год назад тоже бывает трудно, особенно в больших системах.

## Советы

### Пиши тесты сразу
Во-первых, ты сейчас в контексте задачи, помнишь весь код, понимаешь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Во-вторых, в будущем, скорее всего будет более важная или более интересная задача на создание продуктовой фичи или рефакторинг.
В-третьих, если задачу уже приняли, или она даже дошла до продакшена, то психологически она уже считается завершенной и вы вряд ли сами захотите вернуться к ней.
В-четвертых, лучше сразу заложить время в оценку задачи, тем самым вы оставите себе время на спокойное написание тестов. У представителей бизнеса будет меньше вопросов в духе "а нельзя как-то без тестов", если им просто не сказать об этом.


__________________________________________________________
Рандомные мысли:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- Не нужно бояться того, что тесты будут падать после изменений. Это показательно того, что что-то изменилось. И нужно проанализировать - сломали ли вы что-нибудь или же старые тесты перестали соответствовать новому поведению
- Абстрактные классы никак не протестировать, набрать еще набор сущностей, которые не поддаются тестам (enum, если собираем данные по .ts-файлам)
- -
