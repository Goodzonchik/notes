Тесты один из мощнейших инструментов разработки программного обеспечения. Сегодня попытаемся разобраться в чем 

### 1. Тесты могут найти баги там, где их никто не нашел
Если код пишется на старый функционал, то есть вероятность найти баги, которые не были найдены тестировщиками и пользователями.

Если код пишется на только что написанный функционал, то есть шанс найти различные кейсы, которые не были учтены при разработке. А исправить ошибку до того, как код пойдет в тестирование гораздо дешевле для всего процесса разработки.



### 2. Помимо того, что код должен быть читаемым, код должеен быть тестируемым.

Код должен быть тестируемым,  практика в написании тестов позволяет писать более удобный код для тестирования.
Если вам легко написать на код тест, скорее всего это значит, что код легко читается, и у него простая логика. Если у него простая логика и код понятный, значит его легко поддерживать.

Способы декомпозиции:
Например, в Angular-приложении легче протестировать сервис, чем компонент. Одним из способов упрощения тестирования будет вынесение логики в сервис, тем самым упростить тестирование.

```
// У нас есть сервис для запроса данных с бэкенда

export class CompanyDenialReasonsService {
    constructor(private http: HttpClient) { }

    public getUsers<User>(): Observable<User> {
        const url = 'https://example.com/getUsers';

        return this.http.get<User>(url);
    }
}

// 
Тут можно попробовать сделать пример компонента с запросом на бэк + отображение нотификации + какой-нибудь маппинг в pipe от rxds.


В упрощенном тесте будет лишь проверка того, какие view нам вернет новый сервис.
У компонента будет одна зависимость. И не нужно запариваться за кучу моков и  тестов и т.д. Тестируем только view-часть

```


Также стоит сделать акцент на введении правильных абстракций в коде. Каждая абстракция будет иметь четкие границы ответственности. Также одним из ограничений, мы задаем входные и выходные значения.
Протестировав отдельно абстракцию (например, реализуем ее через через Angular-сервис или функция для сложных вычислений), мы можем мокировать его ответы в месте использования при написании теста на интерацию этой абстракции.
Также можно выделить часть логики за фасад.

```
Тестируем компонент, который отрисовывает данные, например по компании. Для этого нужно вызвать несколько запросов к бэкенду.

Каждый вызов находится в отдельном сервисе и легко тестируется сам по себе.

Если делать вызовы последовательно в самом компоненте, например так

// TODO расписать поподробнее преобразования, чтобы было больше "плохого кода"
OnInit(){
  value1$ = service1.getData$().pipe(map(...));
  value2$ = service2.getData$().pipe(map(...));
  value3$ = service3.getData$().pipe(map(...));
  value4$ = service4.getData$().pipe(map(...));
  value5$ = service5.getData$().pipe(map(...));
}

В таком случае нам надо в тесте сделать mock-и для всех вызовов. И если мы будем тестировать отображение value5$, нам надо будет замокать вызовы всех сервисов, хотя бы на заглушки.

Хорошим вариантом может быть - сделать один сервис, который будет возвращать значения всех нужных нам сервисов. Своебразный фасад.

OnInit(){
  value1$ = facadeService.getData1$();
  value2$ = facadeService.getData2$();
  value3$ = facadeService.getData2$();
  value4$ = facadeService.getData2$();
  value5$ = facadeService.getData2$();
}

Сам тест
// TODO дописать примеры элегантного мокирования
```


### 3. Нужно понимание того,  как тестировать, знать теорию чтобы писать хорошие тесты. Также надо знать и инструменты. 

При передаче задачи в ревью, стоит уделить внимание не только на сам код, но и на тесты. Разумно будет подключить на этой стадии более компетентных людей в тестах, а именно QA-специалистов. Они смогут сказать, каких тестов не хватает или как лучше поправить тесты. Также они могут показать какие-то моменты связанные с теорией тестирование, чтобы разработчик мог правильные тесты.
При такам подходе, появляется большее смещение в сторону shiftleft-тестировании, так как тестирование больше и правильнее раскрывается еще на стадии ревью, перед тестированием.

#### Например:

Если не включен `strictNullCheck`, то функция легко может принимать `null` как аргумент, не смотря на то, что у нас тип указан как сторка. Такой кейс довольно распространен, и если не сделать проверку на `null`, то можно легко получить ошибку в рантайме. Такой кейс можно решишь включение флага `strictNullCheck`, но если у вас legacy-проект, то так просто его включить может быть очень затратно.

```
function someFunction(someArg: string): void {
  ...
}

someFunction(null) //IDE и компилятор не будут ругаться, можно легко забыть про такой кейс при тестировании.
```

*Пометки по пункту:*
*Можно использовать отчет по code coverage, чтобы проверить все ли ветки(branches) были покрыты тестами*


### 4. Не всегда покрытие говорит верные цифры
Например, можно написать тест, который делает should created для компонента или сервиса. 
В таком случае каждый импорт будет засчитан за строку в покрытии.

Научитесь понимать какие метрики и за что отвечают.  Научитесь их читать.

Если есть enum ли какая-то модель данны, то при ее использовании тоже увеличивается тестовое покрытие, хотя enum может не использоваться вообще, а быть ненужным полем, которое отпавили с бэка в dto, но на фронте оно не нужно.

Пример: в rxds если сделать map, который поменяет порядок данных. По идее надо скормить туда 2 набора данных, отсортированный для одного теста и не сортированный для проверки сортировки (!!! проверить кейс)

```
// Пример метода:

getUsers$(): Observable<HttpResponse<User[]>> {
  return this.httpClient.get<User[]>(url)
             .pipe(
                map(users => users.sort((user1, user2) => user1.age - user2.age))
             )

  );
}

// Пример теста:

it('При получении списка юзеров, проверить что они отсортированны по дате', done => {
    when(httpClientMock.get(url)).thenReturn(...);
            

    // TODO дописать marble пример.

    expect(testService.getUsers$()).toBeObservable(expected);
```

5. Если нет тестов совсем, то не пренебрегайте хотя бы тестом, который создается по умолчанию should created.
Такой тест может показать изменение зависимостей.

Но стоит задумать о том, чтобы начать добавлять тесты в свое приложение, например:
писать тесты на новый функционал, а на старый функционал завести задачи с разным приоритетом критичности и брать их как технический долг.


6. Обязательно выработайте договоренности по тому, как писать тесты. Тесты - это такой же код и требует таких же процессов, гайдов и тому подобного.
К таким договоренностям может относится код-стайлы.
Правила именования и формирования самого теста, например ААА.
Также можно привлекать вашего коллегу QA-специалиста, который тоже сможет подсказать какие-то моменты, которые можно упустить. 

Но одной из важных договоренностей, или даже обязанностей - является следующее утверждение: тесты нужно писать и нужно следить за их актуальностью. 


8. Написание тестов - это не дополнительная работа, а инструмент разработчика. Его можно сравнить с подсказками в вашей IDE, единственное различие, вы пишите его сами.
Подсказка в IDE подскажет правильность вашего кода на соответствие линтерам, форматировани и  на компилируемость, в то время как тест покажет работоспособность вашего кода и не даст вам сломать приложение при выполнении различных доработок.

Тесты - это инвестиция в будущее качество проекта. Даже если вы идеально знаете свой код и сможете внести доработки, которые его не сломают, то нет гарантии, что его не сломает кто-нибудь другой.
Тесты помогают работать программистам более уверенно в тех частях приложения, с которыми они не знакомы. Да и вернуться к коду, который был написан год назад тоже бывает трудно, особенно в больших системах.


## Советы

### Пиши тесты сразу
Во-первых, ты сейчас в контексте задачи, помнишь весь код, понимаешь как он работает. Если не написать тесты сейчас, то в будущем на это все потребуется потратить время.
Во-вторых, в будущем, скорее всего будет более важная или более интересная задача на создание продуктовой фичи или рефакторинг.
В-третьих, если задачу уже приняли, или она даже дошла до продакшена, то психологически она уже считается завершенной и вы вряд ли сами захотите вернуться к ней.
В-четвертых, лучше сразу заложить время в оценку задачи, тем самым вы оставите себе время на спокойное написание тестов. У представителей бизнеса будет меньше вопросов в духе "а нельзя как-то без тестов", если им просто не сказать об этом.




__________________________________________________________
Рандомные мысли:
- инструменты могут найти ошибки, которые тесты могут не найти (поискать примеры) (Мысли есть сервис, который повторяется или пайп. Можно сделать свой shematic, который будет содержать не только тест "should created".)
- 
